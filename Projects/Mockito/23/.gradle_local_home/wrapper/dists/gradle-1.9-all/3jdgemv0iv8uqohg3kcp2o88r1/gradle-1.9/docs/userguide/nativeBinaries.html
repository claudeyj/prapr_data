<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter&nbsp;54.&nbsp;Building native binaries</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide"><link rel="up" href="userguide.html" title="Gradle User Guide"><link rel="prev" href="signing_plugin.html" title="Chapter&nbsp;53.&nbsp;The Signing Plugin"><link rel="next" href="build_lifecycle.html" title="Chapter&nbsp;55.&nbsp;The Build Lifecycle"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="Chapter&nbsp;53.&nbsp;The Signing Plugin">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="Chapter&nbsp;55.&nbsp;The Build Lifecycle">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="nativeBinaries"></a>Chapter&nbsp;54.&nbsp;Building native binaries</h1></div></div></div><div class="note"><p>
            The Gradle support for building native binaries is currently <a class="link" href="feature_lifecycle.html">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.
        </p></div><p>
        The various native binary plugins add support for building native software components from C++, C and Assembler sources.
        While many excellent build tools exist for this space of software development, Gradle offers developers it's trademark power and flexibility
        together with the dependency management practices more traditionally found in the JVM development space.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N156B8"></a>54.1.&nbsp;Tool chain support</h2></div></div></div><p>
            Gradle offers the ability to execute the same build using different tool chains. You can ontrol which tool chain will be used to build
            by changing the operating system PATH to include the desired tool chain compiler. Alternatively, you can configure the tool chains directly,
            as described in the `Native Binary Variants` section, below.
        </p><p>
            The following tool chains are supported:
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N156BF">
                <tr><td>Operating System</td><td>Tool Chain</td><td>Notes</td></tr>
            <tr>
                <td>Linux</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td><td></td>
            </tr><tr>
                <td>Linux</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td><td></td>
            </tr><tr>
                <td>Mac OS X</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td><td>Using GCC distributed with XCode.</td>
            </tr><tr>
                <td>Mac OS X</td><td><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></td><td>Using Clang distributed with XCode.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://www.microsoft.com/visualstudio/en-us" target="_top">Visual C++</a></td><td>Windows XP and later, Visual C++ 2010 and later.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></td><td>Windows XP and later, using GCC distributed with Cygwin.</td>
            </tr><tr>
                <td>Windows</td><td><a class="ulink" href="http://www.mingw.org/" target="_top">MinGW</a></td><td>Windows XP and later.</td>
            </tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15715"></a>54.2.&nbsp;Component model</h2></div></div></div><p>
            A native binary project defines a set of <a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> and <a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> components,
            each of which Gradle maps to a number of <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> outputs.
            For each <code class="literal">executable</code> or <code class="literal">library</code> defined, Gradle adds a <a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a> with the same name.
            Each of these functional source sets will contain a language-specific source set for each of the languages supported by the project.
        </p><p>
            To build either a static or shared native library binary,
            a <a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a> component is added to the <code class="literal">libraries</code> container.
            Each <code class="literal">library</code> component can produce at least one <a class="ulink" href="../dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a>
            and at least one <a class="ulink" href="../dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a>.
        </p><div class="example"><a name="cppLibraries"></a><p class="title"><b>Example&nbsp;54.1.&nbsp;Defining a library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    hello {}
}</pre></div></div><br class="example-break"><p>
            To build an executable binary,
            an <a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a> component is added to the <code class="literal">executables</code> container
            and associated with a set of sources.
        </p><div class="example"><a name="cppExecutables"></a><p class="title"><b>Example&nbsp;54.2.&nbsp;Defining executable components</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {}
}</pre></div></div><br class="example-break"><p>
            In many cases, more than one native binary can be produced for a component.
            These binaries may vary based on the tool chain used to build, the compiler/linker flags supplied, the dependencies
            provided, or additional source files provided. Each native binary produced for a component is referred to as <code class="literal">variant</code>.
            Binary variants are discussed in detail below.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N1576E"></a>54.3.&nbsp;Tasks</h2></div></div></div><p>
            For each <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> that can be produced by a build,
            a single <code class="literal">lifecycle task</code> is constructed that can be used to create that binary, together with a set of sub-tasks that do the actual
            work of compiling, linking or assembling the binary.
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N1577B">
                <tr><td>Component Type</td><td>Native Binary Type</td><td>Lifecycle task</td><td>Location of created binary</td></tr>
            <tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativebinaries.Executable.html" target="_top"><code class="classname">Executable</code></a></td><td><a class="ulink" href="../dsl/org.gradle.nativebinaries.ExecutableBinary.html" target="_top"><code class="classname">ExecutableBinary</code></a></td><td><code class="literal">mainExecutable</code></td><td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$project.name</code></em></code></td>
            </tr><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a></td><td><a class="ulink" href="../dsl/org.gradle.nativebinaries.SharedLibraryBinary.html" target="_top"><code class="classname">SharedLibraryBinary</code></a></td><td><code class="literal">mainSharedLibrary</code></td><td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/lib<em class="replaceable"><code>$project.name</code></em>.so</code></td>
            </tr><tr>
                <td><a class="ulink" href="../dsl/org.gradle.nativebinaries.Library.html" target="_top"><code class="classname">Library</code></a></td><td><a class="ulink" href="../dsl/org.gradle.nativebinaries.StaticLibraryBinary.html" target="_top"><code class="classname">StaticLibraryBinary</code></a></td><td><code class="literal">mainStaticLibrary</code></td><td><code class="filename"><em class="replaceable"><code>$buildDir</code></em>/binaries/<em class="replaceable"><code>$project.name</code></em>.a</code></td>
            </tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N157CF"></a>54.3.1.&nbsp;Working with shared libraries</h3></div></div></div><p>
                For each executable binary produced, the <code class="literal">cpp</code> plugin provides an <code class="literal">install${binary.name}</code> task,
                which creates a development install of the executable, along with the shared libraries it requires.
                This allows you to run the executable without needing to install the shared libraries in their final locations.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:languages"></a>54.4.&nbsp;Supported Languages: C, C++ and Assembler</h2></div></div></div><p>
            Presently, Gradle supports building native binaries from any combination of C++, C and Assembler sources.
            A native binary project will contain one or more named <code class="literal">FunctionalSourceSet</code> instances (eg 'main', 'test', etc),
            each of which can contain <code class="literal">LanguageSourceSet</code>s containing C++, C or Assembler source files.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N157E6"></a>54.4.1.&nbsp;C++ support</h3></div></div></div><p>
                C++ language support is provided by means of the <code class="literal">'cpp'</code> plugin.
            </p><div class="example"><a name="cppPlugin"></a><p class="title"><b>Example&nbsp;54.3.&nbsp;The 'cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'cpp'</span></pre></div></div><br class="example-break"><p>
                C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>,
                which defines a set of C++ source files and optionally a set of exported header files (for a library).
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a> contains
                <code class="filename">.cpp</code> source files in <code class="filename">src/${name}/cpp</code>,
                and header files in <code class="filename">src/${name}/headers</code>.
            </p><p>
                While the <code class="literal">cpp</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>,
                it is possible to extend or override these defaults to allow for a different project layout.
            </p><div class="example"><a name="cppSourceSet"></a><p class="title"><b>Example&nbsp;54.4.&nbsp;C++ source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.cpp"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a library named 'main', files in <code class="filename">src/main/headers</code> are considered the &ldquo;public&rdquo; or &ldquo;exported&rdquo; headers.
                Header files that should not be exported (but are used internally) should be placed inside the <code class="filename">src/main/cpp</code> directory (though be aware that
                such header files should always be referenced in a manner relative to the file including them).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15829"></a>54.4.2.&nbsp;C support</h3></div></div></div><p>
                C language support is provided by means of the <code class="literal">'c'</code> plugin.
            </p><div class="example"><a name="cPlugin"></a><p class="title"><b>Example&nbsp;54.5.&nbsp;The 'c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'c'</span></pre></div></div><br class="example-break"><p>
                C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>,
                which defines a set of C source files and optionally a set of exported header files (for a library).
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> contains
                <code class="filename">.c</code> source files in <code class="filename">src/${name}/c</code>,
                and header files in <code class="filename">src/${name}/headers</code>.
            </p><p>
                While the <code class="literal">c</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>,
                it is possible to extend or override these defaults to allow for a different project layout.
            </p><div class="example"><a name="cSourceSet"></a><p class="title"><b>Example&nbsp;54.6.&nbsp;C source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    hello {
        c {
            source {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/source"</span>
                include <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"**/*.c"</span>
            }
            exportedHeaders {
                srcDir <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"src/include"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
                For a library named 'main', files in <code class="filename">src/main/headers</code> are considered the &ldquo;public&rdquo; or &ldquo;exported&rdquo; headers.
                Header files that should not be exported (but are used internally) should be placed inside the <code class="filename">src/main/c</code> directory (though be aware that
                such header files should always be referenced in a manner relative to the file including them).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N1586C"></a>54.4.3.&nbsp;Assembler support</h3></div></div></div><p>
                Assembly language support is provided by means of the <code class="literal">'assembler'</code> plugin.
            </p><div class="example"><a name="assemblerPlugin"></a><p class="title"><b>Example&nbsp;54.7.&nbsp;The 'assembler' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'assembler'</span></pre></div></div><br class="example-break"><p>
                Assembler sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>,
                which defines a set of Assembler source files.
                By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a> contains
                <code class="filename">.s</code> source files under <code class="filename">src/${name}/asm</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15890"></a>54.5.&nbsp;Configuring the compiler, assembler and linker</h2></div></div></div><p>
            Each binary to be produced is associated with a set of compiler and linker settings, which include command-line arguments as well as macro definitions.
            These settings can be applied to all binaries, an individual binary, or selectively to a group of binaries based on some criteria.
        </p><div class="example"><a name="allBinarySettings"></a><p class="title"><b>Example&nbsp;54.8.&nbsp;Settings that apply to all binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro for every binary</span>
    cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"NDEBUG"</span>

    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define toolchain-specific compiler and linker options</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-O2"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-fno-access-control"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-S"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/DEBUG"</span>
    }
}</pre></div></div><br class="example-break"><p>
            Each binary is associated with a particular <a class="ulink" href="../dsl/org.gradle.nativebinaries.ToolChain.html" target="_top"><code class="classname">ToolChain</code></a>, allowing settings to be targeted based on
            this value.
        </p><p>
            It is easy to apply settings to all binaries of a particular type:
        </p><div class="example"><a name="allSharedLibraryBinarySettings"></a><p class="title"><b>Example&nbsp;54.9.&nbsp;Settings that apply to all shared libraries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// For any shared library binaries built with Visual C++, define the DLL_EXPORT macro</span>
binaries.withType(SharedLibraryBinary) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
        cCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
        cCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
    }
}</pre></div></div><br class="example-break"><p>
            Furthermore, it is possible to specify settings that apply to all binaries produces for a particular <code class="literal">executable</code>
            or <code class="literal">library</code> component:
        </p><div class="example"><a name="componentBinarySettings"></a><p class="title"><b>Example&nbsp;54.10.&nbsp;Settings that apply to all binaries produced for the 'main' executable component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp) {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"/Zi"</span>
            } <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">else</span> {
                assembler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
            }
        }
    }
}</pre></div></div><br class="example-break"><p>
            The above example will apply the supplied configuration to all <code class="literal">executable</code> binaries built.
        </p><p>
            Similarly, settings can be specified to target binaries for a component that are of a particular type:
            eg all <code class="literal">shared libraries</code> for the <code class="literal">main library</code> component.
        </p><div class="example"><a name="sharedLibraryArgs"></a><p class="title"><b>Example&nbsp;54.11.&nbsp;Settings that apply only to shared libraries produced for the 'main' library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    main {
        binaries.withType(SharedLibraryBinary) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Define a preprocessor macro that only applies to shared libraries</span>
            cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"DLL_EXPORT"</span>
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N158DB"></a>54.6.&nbsp;Library Dependencies</h2></div></div></div><p>
            Dependencies for C++ projects are binary libraries that export header files. The header files are used during compilation, with the compiled
            binary dependency being used during the linking.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N158E0"></a>54.6.1.&nbsp;Dependencies within the same project</h3></div></div></div><p>
               A set of sources may depend on header files provided by another binary component within the same project.
               A common example is a native executable component that uses functions provided by a separate native library component.
           </p><p>
               Such a library dependency can be easily provided to source set associated with the <code class="literal">executable</code> component:
           </p><div class="example"><a name="cppSourceLibrary"></a><p class="title"><b>Example&nbsp;54.12.&nbsp;Providing a library dependency to the source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            lib libraries.hello
        }
    }
}</pre></div></div><br class="example-break"><p>
               Alternatively, a library dependency can be provided directly to the <code class="literal">ExecutableBinary</code> for the <code class="literal">executable</code>.
           </p><div class="example"><a name="cppBinaryLibrary"></a><p class="title"><b>Example&nbsp;54.13.&nbsp;Providing a library dependency to the binary</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executables {
    main {
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Each executable binary produced uses the 'hello' static library binary</span>
            lib libraries.hello.<span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">static</span>
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15906"></a>54.6.2.&nbsp;Project Dependencies</h3></div></div></div><p>
                For a component produced in a different Gradle project, the notation is similar.
            </p><div class="example"><a name="cppProjectDependencies"></a><p class="title"><b>Example&nbsp;54.14.&nbsp;Declaring project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":lib"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp-lib"</span>
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":exe"</span>) {
    apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"cpp-exe"</span>
    evaluationDependsOn(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":lib"</span>)

    sources {
        main {
            cpp {
                lib project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":lib"</span>).libraries.main
            }
        }
    }
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15915"></a>54.6.3.&nbsp;External Dependencies</h3></div></div></div><p>
                External dependencies (i.e. from a repository, not a subproject) are specified using the following syntax:
            </p><div class="example"><a name="cppExternalDependencies"></a><p class="title"><b>Example&nbsp;54.15.&nbsp;Declaring dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    main {
        cpp {
            dependency group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"some-org"</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"some-lib"</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.0"</span>
        }
    }
}</pre></div></div><br class="example-break"><p>
                Each dependency must be specified with the <code class="literal">dependency</code> method as above and must be declared as part of the source set. The
                <code class="literal">group</code>, <code class="literal">name</code> and <code class="literal">version</code> arguments <span class="emphasis"><em>must</em></span> be supplied.
            </p><p>
                For each declared dependency, two actual dependencies are created. One with the classifier &ldquo;<code class="literal">headers</code>&rdquo; and extension
                &ldquo;<code class="literal">zip</code>&rdquo; which is a zip file of the exported headers, and another with the classifier &ldquo;<code class="literal">so</code>&rdquo; and extension
                &ldquo;<code class="literal">so</code>&rdquo; which is the compiled library binary to link against (which is supplied as a direct input to the g++ link operation).
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:variants"></a>54.7.&nbsp;Native Binary Variants</h2></div></div></div><p>
            For each executable or library defined, Gradle is able to build a number of different native binary variants.
            Examples of different variants include debug vs release binaries, 32-bit vs 64-bit binaries, and binaries produced
            by GCC vs binaries produced by Clang.
        </p><p>
            Binaries produced by Gradle can be differentiated on
                <a class="link" href="nativeBinaries.html#native_binaries:build_type">build type</a>,
                <a class="link" href="nativeBinaries.html#native_binaries:target_platform">target platform</a>,
                <a class="link" href="nativeBinaries.html#native_binaries:flavor">flavor</a> and
                <a class="link" href="nativeBinaries.html#native_binaries:tool_chain">tool chain</a>.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:build_type"></a>54.7.1.&nbsp;Build type</h3></div></div></div><p>
                The <code class="literal">build type</code> determines various non-functional aspects of a binary, such as whether debug information is included,
                or what optimisation level the binary is compiled with. Typical build types are 'debug' and 'release', but a project
                is free to define any set of build types.
            </p><div class="example"><a name="buildTypes"></a><p class="title"><b>Example&nbsp;54.16.&nbsp;Defining build types</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildTypes {
    debug {}
    release {}
}</pre></div></div><br class="example-break"><p>
                For a build type, a Gradle project will typically define a set of compiler/linker flags per tool chain.
            </p><div class="example"><a name="buildTypeConfig"></a><p class="title"><b>Example&nbsp;54.17.&nbsp;Configuring debug binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">binaries.all {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in Gcc &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"-g"</span>
    }
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (toolChain in VisualCpp &amp;&amp; buildType == buildTypes.debug) {
        cppCompiler.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/Zi'</span>
        cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'DEBUG'</span>
        linker.args <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'/DEBUG'</span>
    }
}</pre></div></div><br class="example-break"><div class="note">
                At this stage, it is completely up to the build script to configure the relevant compiler/linker flags for each
                build type. Future versions of Gradle will automatically include the appropriate debug flags for any 'debug' build
                type, and may be aware of various levels of optimisation as well.
            </div><p>
                If no build types are defined for a component, then all binaries are built with a single, default build type called 'debug'.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:target_platform"></a>54.7.2.&nbsp;Target platform</h3></div></div></div><p>
                An executable or library can be built to run on different operating systems and cpu architectures, with a variant being
                produced for each target platform.
                Gradle defines each target OS/architecture combination as a <a class="ulink" href="../dsl/org.gradle.nativebinaries.Platform.html" target="_top"><code class="classname">Platform</code></a>, and
                a project may be configured with different <code class="literal">targetPlatforms</code>.
            </p><div class="example"><a name="targetPlatforms"></a><p class="title"><b>Example&nbsp;54.18.&nbsp;Defining target platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">targetPlatforms {
    x8<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">6</span> {
        architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86"</span>
    }
    x6<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span> {
        architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"x86_64"</span>
    }
    itanium {
        architecture <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ia-64"</span>
    }
}</pre></div></div><br class="example-break"><div class="note">
                When a platform does not define an architecture or operating system, the default target of the tool chain
                is assumed. In the example above, the <code class="literal">operatingSystem</code> is not defined, so Gradle will assume that the tool chain
                is configured to build for the correct operating system, and will not supply any specific
                compiler/linker flags to target a particular operating system.
            </div><p>
                The core Gradle tool chains support the following architectures out of the box. There is not currently any core
                support for building for different operating systems.
            </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><div class="table-contents"><table id="N1599D">
                    <tr><td>Tool Chain</td><td>Architectures</td></tr>
                <tr>
                    <td>GCC</td><td>x86, x86_64</td>
                </tr><tr>
                    <td>Clang</td><td>x86, x86_64</td>
                </tr><tr>
                    <td>Visual C++</td><td>x86, x86_64, ia-64</td>
                </tr></table></div></div><p>
                Cross-compiling is possible with the <a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/Gcc.html" target="_top"><code class="classname">Gcc</code></a> and <a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/Clang.html" target="_top"><code class="classname">Clang</code></a> tool chains,
                by programmatically adding support for additional target platforms.
                This is done using the <a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/PlatformConfigurableToolChain.html" target="_top"><code class="classname">PlatformConfigurableToolChain</code></a> API.
                Each added <a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/TargetPlatformConfiguration.html" target="_top"><code class="classname">TargetPlatformConfiguration</code></a> defines support for a particular target platform,
                and supplies additional tool arguments that are required to target this platform.
            </p><div class="note">
                There is no direct support for cross platform source configuration (&agrave; la <a class="ulink" href="http://www.gnu.org/s/autoconf/" target="_top">autoconf</a>) at this time.
            </div><p>
                If no target platforms are defined for a project, then all binaries are built to target a default platform
                which does not specify an <code class="literal">architecture</code> or <code class="literal">operatingSystem</code>, hence using the tool chain default.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:flavor"></a>54.7.3.&nbsp;Flavor</h3></div></div></div><p>
                Each component can have a set of named <code class="literal">flavors</code>, and a separate binary variant can be produced for each flavor.
                While the <code class="literal">build type</code> and <code class="literal">target platform</code> variant dimensions have a defined meaning in Gradle,
                each project is free to define any number of flavors and apply meaning to them in any way.
            </p><p>
                An example of component flavors might differentiate between 'demo', 'paid' and 'enterprise' editions of the component,
                where the same set of sources is used to produce binaries with different functions.
            </p><div class="example"><a name="flavors"></a><p class="title"><b>Example&nbsp;54.19.&nbsp;Defining component flavors</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">libraries {
    hello {
        flavors {
            english {}
            french {}
        }
        binaries.all {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (flavor == flavors.french) {
                cppCompiler.define <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"FRENCH"</span>
            }
        }
        source sources.lib
    }
}</pre></div></div><br class="example-break"><p>
                In the above example, a library is defined with a 'english' and 'french' flavor. When compiling the 'french'
                variant, a separate macro is defined which leads to a different binary being produced.
            </p><p>
                If no flavor is defined for a component, then a single default flavor named 'default' is used.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:tool_chain"></a>54.7.4.&nbsp;Tool chain</h3></div></div></div><p>
                Within a single build it is possible to build the same component with different tool chains. To do so, the set
                of tool chains for a project must be explicitly configured, and a separate variant will be produced for each
                available tool chain. Attempting to build the variant for a tool chain that is not available on the current
                machine will result in an error.
            </p><div class="example"><a name="toolChains"></a><p class="title"><b>Example&nbsp;54.20.&nbsp;Defining tool chains</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">toolChains {
    visualCpp(VisualCpp) {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Specify the installDir if Visual Studio cannot be located by default</span>
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// installDir "C:/Apps/Microsoft Visual Studio 10.0"</span>
    }
    gcc(Gcc) {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Uncomment to use a GCC install that is not in the PATH</span>
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// path "/usr/bin/gcc"</span>
    }
    clang(Clang)
}</pre></div></div><br class="example-break"><p>
                The supported tool chain types are:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/Gcc.html" target="_top"><code class="classname">Gcc</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/Clang.html" target="_top"><code class="classname">Clang</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/nativebinaries/toolchain/VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a></p></li></ul></div><p>
                Each tool chain implementation allows for a certain degree of configuration (see the API documentation for more details).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="N15A25"></a>54.7.5.&nbsp;Building all possible variants</h3></div></div></div><p>
                When a set of build types, target platforms, flavors and tool chains is defined for a component,
                a <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> model element is created for every possible
                combination of these. However, in many cases it is not possible to build a particular variant, perhaps because
                the tool chain for that variant is not available on the current machine, or the tool chain is not able to build
                for the specified target architecture.
            </p><p>
                If a binary variant cannot be built for any reason, then the <a class="ulink" href="../dsl/org.gradle.nativebinaries.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a>
                associated with that variant will not be <code class="literal">buildable</code>. It is possible to use this property to create a task
                to generate all possible variants on a particular machine.
            </p><div class="example"><a name="buildable"></a><p class="title"><b>Example&nbsp;54.21.&nbsp;Building all possible variants</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task buildAllExecutables {
    dependsOn binaries.withType(ExecutableBinary).matching {
        it.buildable
    }
}</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="N15A43"></a>54.8.&nbsp;Publishing</h2></div></div></div><p>
            The <code class="literal">cpp-exe</code> and <code class="literal">cpp-lib</code> plugins configure their respective output binaries to be publishable as part of the
            <code class="literal">archives</code> configuration. To publish, simply configure the <code class="literal">uploadArchives</code> task as per usual.
        </p><div class="example"><a name="cppPublish"></a><p class="title"><b>Example&nbsp;54.22.&nbsp;Uploading exe or lib</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">group = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"some-org"</span>
archivesBaseName = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"some-lib"</span>
version = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">1.0</span>

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: uri(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${buildDir}/repo"</span>))
        }
    }
}</pre></div></div><br class="example-break"><p>
            The <code class="literal">cpp-exe</code> plugin publishes a single artifact with extension &ldquo;<code class="literal">exe</code>&rdquo;. The <code class="literal">cpp-lib</code> plugin
            publishes two artifacts; one with classifier &ldquo;<code class="literal">headers</code>&rdquo; and extension &ldquo;<code class="literal">zip</code>&rdquo;, and one with classifier
            &ldquo;<code class="literal">so</code>&rdquo; and extension &ldquo;<code class="literal">so</code>&rdquo; (which is the format used when consuming dependencies).
        </p><div class="note"><p>
                Currently, there is no support for publishing the dependencies of artifacts in POM or Ivy files. Future versions will support this.
            </p></div></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="signing_plugin.html" title="Chapter&nbsp;53.&nbsp;The Signing Plugin">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="build_lifecycle.html" title="Chapter&nbsp;55.&nbsp;The Build Lifecycle">Next</a></div></div></div></body></html>